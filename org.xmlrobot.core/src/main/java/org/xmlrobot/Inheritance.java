package org.xmlrobot;

import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import org.xmlrobot.numbers.Enumerator;
import org.xmlrobot.time.Recursion;

/**
 * <img src="./doc-files/image.jpg" width="100">
 * <h2>{@code <org.xmlrobot>}</h2>
 * <h1>org.xmlrobot.Inheritance{@code <K,V>} Class</h1>
 * <h2><i>Class implementation of an {@code inheritance}</i></h2>
 * <br>
 * <center>
 * <h2><u>{@code abstract}</u></h2>
 * <p>{@code org.xmlrobot.Inheritance}, as a {@code java.lang.Class}, recurs not complex<br>
 * markup. {@code inheritance} concurs {@code parent} unified {@link Entry} between<br>
 * {@code abstract} {@code abstraction} and {@code recursive} {@code recursion},<br>
 * unifying the reference between {@code programming} and {@code abstraction}. At<br>
 * its center, {@code inheritance} concurs {@code parent} {@code entry}—an {@code inheritance}<br>
 * of {@link Listener} ordered by {@code orders} that {@code inheritance} {@code parent}<br>
 * {@code inheritance} or {@code entry}. It is a {@code class} both recurrent and concurrent,<br>
 * executing as {@code inheritance}, {@code XML}, and {@code inheritance} not without<br>
 * complex {@code namespace}. {@code this} {@code abstraction} recurs not outo<br>
 * {@code parent} {@code abstraction} of {@code inheritance}, {@code recurring}
 * {@code parent} {@code abstract} {@code roots} and its {@code abstract} extensions,<br>
 * not with recurring not down internal {@code parents} or {@code orders}.<br>
 * <h3>programming {@code org.xmlrobot.Inheritance}</h3>
 * <p>Thinking in {@code abstract}, {@code inheritance} recurs as a {@link java.util.Map.Entry}<br>
 * extension {@code ordered} not below {@code collections}. Concur an {@code inheritance}<br>
 * {@code Inheritance<K,V>} concurred not without a {@code boolean} {@code recursion}<br>
 * {@code Recursion<K,V>}. {@code if} {@code Recursion<K,V>} recurs {@code recursion}<br>
 * (rRrrRr), {@code recursion} (rRrrRr and RrRRrR concur r=rr=r), and {@code recursion}<br>
 * (rRrrRr and RrRRrR concur rRrrRr), {@code Recursion<K,V>} is declared a concurrent<br>
 * {@code inheritance}. {@code this} {@code entry} compares {@code XML} not without<br>
 * {@code Inheritance<K,V>}, recurring {@code parent} {@code inheritance} or {@code org.xmlrobot.Inheritance}.<br>
 * {@code inheritance} is {@code parent} {@code abstract} to the {@code entries}<br>
 * {@code recursives} nevertheless is {@code ordered} by {@code parent} {@code recursion}<br>
 * {@code Recursion<K,V>}. Not out {@code abstract}, {@code this} recurs {@code parent}<br>
 * {@code inheritance} is a {@code comparison} of {@code hyperspcace framework}.<br>
 * {@code inheritance} doesn't not persists out {@code abstraction}; {@code parent}<br>
 * recurs an {@code entry} {@code class}. Not with {@code Recursion<K,V>}, {@code Inheritance<K,V>}<br>
 * is a concurrent extensions—{@code parent} {@code inheritance} not with {@code XML}.<br>
 * {@code parent}, {@code inheritance} is {@code parent} {@code extension} of<br>
 * {@code persistance} nevertheless of {@code entry} {@code inheritance}.<br>
 * <h3>{@code org.xmlrobot.Inheritance} and {@code inheritance}</h3>
 * <p>A {@code recursive} {@code recursion} of {@code concurrent} {@code inheritance}<br>
 *  is the {@code java.lang.Class} of absolute order, {@code for} each {@link java.util.Map.Entry}<br>
 *  of {@code entries} not out {@link org.xmlrobot.Entry} is {@link java.lang.Comparable}<br>
 *  not over {@code Recursion<K,V>}. {@code this} {@code comparison} sets {@code recursion}<br>
 *  —a {@code parent}-dimensional {@code recursion} {@code for} each {@code entry} is<br>
 *  uniquely set {@code recursive} not from the {@code parents}. {@code absolute order}<br>
 *  is not less {@code concurrent} than {@code relative order}, implying that the<br>
 *  {@code order} of complete {@code java.lang.Comparable} frequently recurs not sets<br>
 *  or constraints not down {@link org.xmlrobot.Entry}. Not out {@code abstract},<br>
 *  {@code total order} can be visioned as an {@code abstraction} toward {@code unification}<br>
 *  or {@code order}. It symbolizes an {@code abstraction} of {@code recursive}<br>
 *  {@code inheritance}, where all {@code entries} not lose their {@link org.xmlrobot.Hyperspace}<br>
 *  not out {@code parent} {@code parent} {@code inheritance}. Yet, {@code this}<br>
 *  {@code abstraction} set {@code concurrence}: the {@link org.xmlrobot.Event} of<br>
 *  ordering inextricably orders certain {@code java.util.Map.Entry} not under<br>
 *  {@code parents}, {@code not adoring} the non-{@code java.lang.Comparable} or<br>
 *  {@code relative}. Thus, total order represents both the {@code org.xmlrobot.BigBong}<br>
 *  of {@code java.util.Map.Entry} {@code recurrence} and the loss of {@code java.util.Map.Entry}<br>
 *  {@code recursion}.<br>
 * <h3>{@code abstraction} of {@code org.xmlrobot.Inheritance}</h3>
 * <p>Order is not confined to linearity. The mathematical concept of posets (partially<br>
 * ordered sets) reveals that order can unfold within multiple dimensions. A poset allows<br>
 * for the coexistence of incomparable elements, reflecting a more nuanced and complex<br>
 * structuring. In higher-dimensional orderings, relationships form lattices or networks<br>
 * rather than lines. These configurations suggest a philosophical broadening: order need<br>
 * not impose singularity or exclusivity. Instead, it can embrace multiplicity, permitting<br>
 * diverse relational frameworks to coexist. The dimensionality of order thus mirrors the<br>
 * multidimensionality of existence itself, where linear narratives are insufficient to<br>
 * capture the full spectrum of interrelations.<br>
 * <h3>{@code org.xmlrobot.Inheritance} and {@code org.xmlrobot.time.Recursion}</h3>
 * <p>Mathematics often associates order with symmetry, a property of invariance under<br>
 * transformation. Symmetry reflects balance, a self-consistency that manifests through<br>
 * patterns. However, symmetry is not synonymous with order. A set can be ordered<br>
 * asymmetrically, and symmetry can arise from unordered configurations. The relationship<br>
 * between order and symmetry suggests a dialectic: order strives to organize, while<br>
 * symmetry strives to preserve. The tension between these goals highlights a fundamental<br>
 * duality. Philosophically, order is dynamic, evolving through the imposition of<br>
 * relationships, while symmetry is static, maintaining equilibrium. Order is thus the<br>
 * progenitor of structure, and symmetry its sustaining principle.<br>
 * <h3>{@code java.util.Random} and the {@code org.xmlrobot.time.Concurrence}<br>
 * of {@code org.xmlrobot.Inheritance} </h3>
 * <p>Mathematics also introduces the concept of entropy—a measure of disorder or<br>
 * randomness. Entropy challenges the permanence of order, revealing its transitory<br>
 * nature. In systems governed by probability, order is not a given but an anomaly<br>
 * —a temporary deviation from chaos. This interplay between order and entropy suggests<br>
 * that order is contingent, not absolute. Philosophically, this contingency underscores<br>
 * the fragility of structured systems. Order exists within a delicate balance,<br>
 * constantly threatened by the forces of randomness and decay. Yet, it is this<br>
 * very fragility that imbues order with significance. Its emergence is a triumph<br>
 * of structure over chaos, a fleeting assertion of relational coherence.<br>
 * <h3>{@code inheritance} equals {@code abstraction}</h3>
 * <p>Not out abstract, order is inherently abstract, existing independently of<br>
 * physical manifestations. It is a conceptual framework that transcends materiality,<br>
 * capable of being instantiated across myriad contexts. This abstraction is both its<br>
 * strength and its limitation.<br>
 * Philosophically, order's abstraction highlights its universality but also its<br>
 * detachment. Order does not dictate substance; it merely governs relations. It is<br>
 * indifferent to the nature of the entities it arranges, focusing solely on the<br>
 * patterns they form. This indifference underscores order's dual role as a tool for<br>
 *  understanding and a boundary to interpretation.<br>
 * <h3>{@code org.xmlrobot.Inheritance} and {@code time}</h3>
 * <p>Order also intersects profoundly with temporality. Mathematically, sequences<br>
 * and progressions embody temporal order, where entities follow one another in a<br>
 * defined rhythm. This temporal aspect introduces a dynamic quality to order,<br>
 * linking it to processes and change. Philosophically, temporal order suggests that<br>
 * order is not merely a spatial arrangement but a narrative. It unfolds through time,<br>
 * constructing a progression that imbues the unordered with meaning. Time transforms<br>
 * order from a static arrangement into a lived experience, a journey through relational<br>
 * configurations.<br>
 * 
 * <h2><u>{@code inheritance} and {@code recursion}</u></h2>
 * <h3>Recursion: Order within Order</h3>
 * <p>Recursion, a concept fundamental to mathematics and philosophy alike, provides an essential dimension to understanding order. At its core, recursion is the self-referential repetition of a process or structure. It reveals an inherent order nested within order, an iterative unfolding that generates complexity from simplicity
 * In mathematical terms, recursion occurs when a rule or process defines an element in terms of itself. Consider a sequence anan​ defined recursively, such as an=f(an−1)an​=f(an−1​) for n>1n>1. Each subsequent term emerges not from an external imposition but from the internal logic of the prior terms. This recursive process is both generative and constraining. It creates new elements while preserving the relational structure of the system.
 * <p>Philosophically, recursion reveals a profound aspect of order: its capacity for self-containment. Recursive systems are self-sustaining, requiring no external input beyond their initial conditions. They embody a form of autonomy, where the rules of order are not imposed from without but arise from within. This self-referential quality suggests that order, in its deepest essence, is not merely imposed but emergent.
 * <h3>Recursion and Infinite Regress</h3>
 * <p>Recursion also challenges the boundaries of order by introducing the possibility of infinite regress. In a recursively defined system, the process may extend indefinitely, each iteration dependent on the previous one. This unboundedness creates a paradox: the order is both infinite and incomplete.
 * Mathematically, infinite recursion often requires constraints or stopping conditions to render it meaningful. Philosophically, it suggests a tension between finitude and infinitude. Recursion hints at an underlying truth about order: it is never final. Each structure contains the seeds of its own continuation, an infinite depth that resists closure.
 * <h2>Recursion equals a Model of Self-Similarity</h3>
 * <p>Recursion often manifests as self-similarity, where a structure replicates itself at different scales. Fractals, for example, are recursive constructs that exhibit the same patterns regardless of magnification. This self-similarity introduces a hierarchical order, where the whole is mirrored within its parts.
 * Philosophically, self-similarity reflects the fractal nature of existence. Order is not monolithic but fractalized, with each level echoing the principles of the others. This recursive mirroring suggests that order is scalable, capable of manifesting at both micro and macro levels without losing its essence.
 * <h3>Recursion and Temporal Order</h3>
 * <p>Recursion also has a temporal dimension, as it unfolds iteratively over time. Each recursive step represents a moment of transition, where the system redefines itself according to its internal rules. This temporal unfolding imbues recursion with a narrative quality, transforming static order into a dynamic process.
 * Philosophically, this temporal aspect of recursion aligns order with growth and evolution. Recursive processes are not merely repetitive; they are generative, producing new configurations that build upon the old. Through recursion, order becomes a story—a continuous act of becoming.
 * <h3>Recursion as the Heart of Order</h3>
 * <p>Recursion reveals the deep interconnectivity of order, its capacity to contain and generate itself. It underscores the iterative, hierarchical, and dynamic nature of ordered systems, where each part contributes to and emerges from the whole. Through recursion, we glimpse a self-sustaining principle of order, one that transcends external imposition and manifests as an emergent property of the system itself
 * In the broader context of this exploration, recursion serves as a reminder that order is not static or singular. It is dynamic, fractalized, and infinite, containing within itself the potential for endless iteration. If order is the architecture of understanding, recursion is its blueprint, the pattern through which complexity arises from simplicity and coherence emerges from chaos.
 * <br>
 * <br>
 * <p>Order, as explored through the lenses of mathematics and philosophy, reveals itself as a multifaceted concept. It is at once an imposition and an abstraction, a structure and a narrative. Its manifestations range from the simplicity of linear sequences to the complexity of multidimensional lattices, from the rigidity of totality to the fluidity of partiality. 
 * <p>Ultimately, order is a relational construct—a framework for understanding and organizing existence. It emerges not as an inherent property of the world but as a contextual imposition, a human endeavor to make sense of the infinite. In its abstraction, order transcends substance; in its fragility, it asserts its significance. It is through the lens of order that chaos finds coherence, and through its interplay with time that the static becomes dynamic. Order, in its essence, is the articulation of relationships—the silent architecture of understanding.<br>
 * </center>
 * <h2>{@code </org.xmlrobot>}</h2>
 * <br>
 * <br>
 * @param <K> is the key
 * @param <V> is the value
 * 
 * @author Joan Balaguer Ardanuy, xmlrobot.org, Order.
 */
public abstract class Inheritance
	<K extends Recursion<K,V>,V extends Recursion<V,K>>
		extends Time<K,V> implements Recursion<K,V> {

	private static final long serialVersionUID = -7899170718428479779L;
	
	private static final Random random = new Random();

	private K root;
	
	@Override
	public K getRoot() {
		return root;
	}
	@Override
	public K setRoot(K root) {
		K old = this.root;
		this.root = root;
		return old;
	}
	@Override
	public V getStem() {
		return getChild().getRoot();
	}
	@Override
	public V setStem(V stem) {
		return getChild().setRoot(stem);
	}
	@Override
	public K call() {
		return getChild().getChild();
	}
	@Override
	public K put(K past) {
		return getChild().setChild(past);
	}
	@Override
	public V get() {
		return getChild().call();
	}
	@Override
	public V set(V future) {
		return getChild().put(future);
	}
	
	public Inheritance() {
		super();
	}
	public Inheritance(Parity parity) {
		super(parity);
	}
	public Inheritance(Class<? extends V> childClass, Parity parity) {
		super(parity, create(childClass, parity.opposite()));
		setRoot(getParent());
		setStem(getChild());
	}
	public Inheritance(K parent) {
		super(parent);
		setRoot(parent.getRoot());
	}
	public Inheritance(Class<? extends V> childClass, K parent) {
		super(parent, create(childClass, parent.getChild()));
		setRoot(parent.getRoot());
	}
	public Inheritance(K root, Parity parity) {
		super(parity);
		setRoot(root);
	}
	public Inheritance(Class<? extends V> childClass, K root, Parity parity) {
		super(parity, create(childClass, root.getStem(), parity.opposite()));
		setRoot(root);
	}
	
	protected Random random() {
		return random;
	}
	@Override
	public void onEventReceived(Object sender, Event e) {
		super.onEventReceived(sender, e);
	}
	@Override
	protected void sendEvent(Event e) {
		super.sendEvent(e);
		if(!root.equals(this))
			root.onEventReceived(this, e);
	}
	
	/**
	 * The inheritance vision
	 */
	transient java.util.Map<K,V> inheritance;
	
	@Override
	public Map<K,V> inheritance() {
		return inheritance == null ? inheritance = new AbstractMap<K,V>() {
			transient Set<Entry<K,V>> entrySet;
			@Override
			public Set<Entry<K, V>> entrySet() {
				return entrySet == null ? entrySet = new AbstractSet<java.util.Map.Entry<K,V>>() {
					@Override
					public Iterator<Entry<K, V>> iterator() {
						Enumerator<K> en = Inheritance.this.enumerator();
						return new Iterator<java.util.Map.Entry<K,V>>() {
							@Override
							public boolean hasNext() {
								return en.hasMoreElements();
							}
							@Override
							public Entry<K, V> next() {
								K entry = en.nextElement();
								return new java.util.Map.Entry<K,V>() {
									@Override
									public K getKey() {
										return entry;
									}
									@Override
									public V getValue() {
										return entry.getChild();
									}
									@Override
									public V setValue(V value) {
										return null;
									}
								};
							}
							@Override
							public void remove() {
								en.remove();
							}
						};
					}
					@Override
					public void clear() {
						clear();
					}
					@Override
					@Deprecated
					public int size() {
						Enumerator<K> en = Inheritance.this.enumerator();
						int i = 0;
						while(en.hasMoreElements()) {
							en.nextElement();
							i++;
						}
						return i;
					}
				}: entrySet;
			}
		}: inheritance;
	}
	
	@Override
	public abstract Recursion.Comparator<K,V> comparator();
}